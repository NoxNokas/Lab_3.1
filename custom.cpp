//---------------------------------------------------------------------------

#include "custom.h"
#include <math.h>

#include "array.h"
//---------------------------------------------------------------------------
// Задача Аренсторфа (начальные условия 1)

const long double TArenstorfModel::m  = 0.012277471;

TArenstorfModel::TArenstorfModel() : TModel()
{
    X0.resize(4);
    X0[0] = 0.994;
    X0[1] = 0;
    X0[2] = 0;
    X0[3] = -2.0015851063790825224053786222;
}

//---------------------------------------------------------------------------

void TArenstorfModel::getRight( const TVector& X, long double t, TVector& Y )
{
    Y.resize(4);
    D1 = pow( pow( X[0] + m, 2 ) + pow( X[1], 2 ), 1.5 );
    D2 = pow( pow( X[0] + m - 1, 2 ) + pow( X[1], 2 ), 1.5 );
    Y[0] = X[2];
    Y[1] = X[3];
    Y[2] = X[0] + 2 * X[3] - (1 - m)*(X[0] + m) / D1 - m * (X[0] + m - 1) / D2;
    Y[3] = X[1] - 2 * X[2] - (1 - m)*X[1] / D1 - m * X[1] / D2;
}

//---------------------------------------------------------------------------
// Задача Аренсторфа (начальные условия 2)

TArenstorfModel2::TArenstorfModel2() : TArenstorfModel()
{
    X0.resize(4);
    X0[0] = 0.994;
    X0[1] = 0;
    X0[2] = 0;
    X0[3] = -2.0317326295573368357302057924;
}
//---------------------------------------------------------------------------

/* Математические маятники */

const double MathPendulum::g = 9.81;

MathPendulum::MathPendulum() : TModel()
{
    /*	Длина нити	*/
    l = 1;

    /*	Масса	*/
    m = 1;

    /*	Коэффициент пропорциональности - изменение энергии в системе	*/
    dE = 0.8;

    X0.resize(2);

    /*	Угол отклонения	*/
    X0[0] = 0.5236;

    /*	Угловая скорость */
    X0[1] = 0;
}



/* Математические маятники: метод вычисления правой части дифференциального уравнения	*/

void MathPendulum::getRight( const TVector& X, long double t, TVector& Y )
{
    extern int mode;

    Y.resize(3);

    Y[0] = X[1];

    /*	Идеальный математический маятник */

    if (mode == 1)
    {
        Y[1] = -(g/l)*sin(X[0]);
    }

    /*	Реальный математический маятник	*/

    else if (mode == 2)
    {
        Y[1] = -g/l*sin(X[0])-(dE*X[1]);
    }
}




//---------------------------------------------------------------------------
/* Пружинные маятники	*/

const double SpringPendulum::g = 9.81;

SpringPendulum::SpringPendulum() : TModel()
{
    /*	Коэффициент жесткости пружины	*/
    k = 1;

    /*	Масса	*/
    m = 1;

    /*	Коэффициент трения скольжения	*/
    mu2 = 0.015;

    /*	Коэффициент вязкого трения	*/
    mu1 = 0.4;

    X0.resize(2);

    /*	Начальное растяжение пружины	*/
    X0[0] = 2;

    /*	Начальная скорость	*/
    X0[1] = 0;
}



/* Пружинные маятники: метод вычисления правой части уравнения	*/

void SpringPendulum::getRight( const TVector& X, long double t, TVector& Y )
{
    extern int mode;

    Y.resize(2);

    Y[0] = X[1];

    /*	Идеальный пружинный маятник	*/
    if (mode == 3)
    {
        Y[1] = -((k*X[0])/m);
    }

    /*	Реальный пружинный маятник с трением вязкости	*/
    else if (mode == 4)
    {
        Y[1] = -((k*X[0])/m)-((mu1*X[1])/m);
    }

    /*	Реальный пружинный маятник с трением скольжения	*/
    else if (mode == 5)
    {
        if ( X[1] > 0 )
        {
            mu2 = -0.015;
        }
        else if ( X[1] < 0 )
        {
            mu2 = 0.015;
        }
        else
        {
            mu2 = 0;
        }

        Y[1] = (mu2*g)-(k/m*X[0]);
    }
}
